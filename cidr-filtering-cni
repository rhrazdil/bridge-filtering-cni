#!/bin/bash

set -euo pipefail

TEST=${TEST:-false}
if [[ $TEST == false ]]; then
    STDIN=$(cat /dev/STDIN)
    CNI_VERSION="$(echo "$STDIN" | jq -r ".cniVersion")"
    CNI_PREV_RESULT="$(echo "$STDIN" | jq -cr ".prevResult")"
fi

LOGFILE="${LOGFILE:-/var/log/cidr-filtering-cni.log}"
exec 2>> $LOGFILE

NFT_BRIDGE_TABLE=bridge
NFT_TABLE=filter

NFT_INGRESS_CHAIN=prerouting
NFT_INGRESS_HOOK=prerouting

NFT_POSTROUTING_CHAIN=postrouting
NFT_EGRESS_HOOK=postrouting

get_object() {
    local json_object="$1"
    local json_path="$2"
    echo "$json_object" | jq -cr "$json_path"
}

get_array_items() {
    local json_object="$1"
    local json_path="$2"
    echo "$json_object" | jq -c $json_path | jq -cr ".[]"
}

get_array_len() {
    local json_object="$1"
    local json_path="$2"
    echo "$json_object" | jq -c "$json_path" | jq ". | length"
}

for_json_array() {
    local json_object="$1"
    local json_path="$2"
    local fn="$3"
    for item in $(get_array_items "$json_object" "$json_path"); do
        $fn $item
    done
}

get_ip_version() {
    local ip_address="$1"
    if [[ "$ip_address" =~ .*:.* ]]
    then
        echo "ip6"
    else
        echo "ip"
    fi
}

create_table() {
    local type="$1"
    local name="$2"
    echo "nft add table $type $name" | tee -a $LOGFILE
}

create_netdev_base_chain() {
    local type="$1"
    local name="$2"
    local chain="$3"
    local hook="$4"
    local device="$5"
    echo "nft add chain $type $name $chain { type filter hook $hook device $device priority -1; policy accept; }" | tee -a $LOGFILE
}

create_base_chain() {
    local type="$1"
    local name="$2"
    local chain="$3"
    local hook="$4"
    echo "nft add chain $type $name $chain { type filter hook $hook priority -1; policy accept; }" | tee -a $LOGFILE
}

create_chain() {
    local type="$1"
    local name="$2"
    local chain="$3"
    echo "nft add chain $type $name $chain" | tee -a $LOGFILE
}

nft_add_rule() {
    local type="$1"
    local table="$2"
    local chain="$3"
    set -- "${@:4}"
    echo "nft add rule $type $table $chain $@" | tee -a $LOGFILE
}

create_rules_for_filtering() {
    local config_id="$1"
    local config="$2"
    local table_type="$3"
    local direction="$4"

    local match_addr="saddr"
    if [[ "$direction" == "egress" ]]; then
        local match_addr="daddr"
    fi
    local match_iface="iifname"
    if [[ "$direction" == "egress" ]]; then
        match_iface="oifname"
    fi

    _create_filtering_chain() {
        local config_id="$1"
        local config="$2"
        local table_type="$3"
        local direction="$4"
        ip netns exec "$CNI_CONTAINERID" $(create_chain "${table_type}" "${NFT_TABLE}" m-"${config_id}"-"${direction}") || exitWithError "${CNI_VERSION}" "Failed to add chain m-${config_id}-${direction}"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${table_type}" "${NFT_TABLE}" m-"${direction}" "${match_iface}" "$CNI_IFNAME" counter jump m-"${config_id}"-"${direction}") || exitWithError "${CNI_VERSION}" "Failed to add rule: jump m-${config_id}-${direction}"
    }

    _create_subnet_rule() {
        local subnet=$1
        if [[ "$(get_object "${subnet}" ".subnet.except")" != "null" ]]; then
            for_json_array "${subnet}" ".subnet.except" _drop_ip
        fi

        if [[ "$(get_object "${subnet}" ".subnet.cidr")" == "null" ]]; then
            exitWithError "${CNI_VERSION}" "cidr must be specified."
        fi
        _accept_cidr "${subnet}"
    }

    _drop_ip() {
        local ip="$1"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} m-${config_id}-${direction}-subnets ${match_iface} $CNI_IFNAME $(get_ip_version "${ip}") ${match_addr} ${ip} counter drop)
    }

    _accept_cidr() {
        local subnet="$1"
        local cidr=$(echo "${subnet}" | jq -r ".subnet.cidr")
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} m-${config_id}-${direction}-subnets ${match_iface} $CNI_IFNAME $(get_ip_version "${cidr}") ${match_addr} ${cidr} counter meta mark set mark or 0x20000)
    }

    _accept_port() {
        local ports="$1"
        local port=$(echo "$ports" | jq -r ".port")
        local protocol=$(echo "$ports" | jq -r ".protocol")

        if [[ "$port" == "null" || "$protocol" == "null" || "$port" == "" || "$protocol" == "" ]]; then
            exitWithError "${CNI_VERSION}" "Port and protocol must be specified."
        else
            ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} m-${config_id}-${direction}-ports ${match_iface} $CNI_IFNAME ${protocol,,} dport ${port} counter meta mark set meta mark "|" 0x00010000)
        fi
    }

    local is_filtering_chain_created=false
    # handle ip subnet
    if [[ $(echo "$config" | jq -r ".${direction}.subnets") != "null" ]]; then
        _create_filtering_chain "${config_id}" "${config}" "${table_type}" "${direction}"
        is_filtering_chain_created=true

        ip netns exec "$CNI_CONTAINERID" $(create_chain "${table_type}" "${NFT_TABLE}" m-"${config_id}"-"${direction}"-subnets) || exitWithError "${CNI_VERSION}" "Failed to add chain m-"${config_id}"-"${direction}"-subnets"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${table_type}" "${NFT_TABLE}" m-"${config_id}"-"${direction}" counter jump m-"${config_id}"-"${direction}"-subnets) || exitWithError "${CNI_VERSION}" "Failed to add rule: jump m-"${config_id}"-"${direction}"-subnets"

        if [[ $(get_array_len "$config" ".${direction}.subnets") == 0 ]]; then
            # example:  ingress: {subnets: []}  => translates to allow all subnets
            ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} m-"${config_id}"-"${direction}"-subnets counter meta mark set mark or 0x20000) || exitWithError "${CNI_VERSION}" "Failed to allow all L3 traffic"
        else
            for_json_array "$config" ".${direction}.subnets" _create_subnet_rule
        fi
    fi

    # handle ports
    if [[ $(echo "$config" | jq -r ".${direction}.ports") != "null" ]]; then
        if [[ "$is_filtering_chain_created" == false ]]; then
            _create_filtering_chain "${config_id}" "${config}" "${table_type}" "${direction}"
            is_filtering_chain_created=true
        fi

        ip netns exec "$CNI_CONTAINERID" $(create_chain "${table_type}" "${NFT_TABLE}" m-"${config_id}"-"${direction}"-ports) || exitWithError "${CNI_VERSION}" "Failed to add chain m-"${config_id}"-"${direction}"-ports"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${table_type}" "${NFT_TABLE}" m-"${config_id}"-"${direction}" counter jump m-"${config_id}"-"${direction}"-ports) || exitWithError "${CNI_VERSION}" "Failed to add rule: jump m-"${config_id}"-"${direction}"-ports"
        
        if [[ $(get_array_len "$config" ".${direction}.ports") == 0 ]]; then
            # example:  "egress": {"ports": []}  => translates to allow all ports
            ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} m-"${config_id}"-"${direction}"-ports counter meta mark set meta mark "|" 0x00010000) || exitWithError "${CNI_VERSION}" "Failed to allow all L4 traffic when not explicit config provided"
        else
            for_json_array "$config" ".${direction}.ports" _accept_port
        fi
    fi
}

exitWithError() {
    local cni_version="$1"
    local message="${2:-""}"
    local details="${3:-""}"
    echo "{\"cniVersion\": \"${cni_version}\",\"msg\":\"${message}\",\"code\":101,\"details\":\"${details}\"}"
    exit 1
}

exitWithSuccess() {
    local cni_version="$1"
    local prev_result="$2"
    if [[ "$prev_result" == "null" ]]; then
        echo "{\"cniVersion\": \"$cni_version\"}"
    else
        echo "$prev_result"
    fi
    exit 0
}

main() {
    case $CNI_COMMAND in
    ADD)
        echo "CNI_NETNS: $CNI_NETNS" >> $LOGFILE
        echo "CNI_CONTAINERID: $CNI_CONTAINERID" >> $LOGFILE
        echo "STDIN: $STDIN" >> $LOGFILE
        echo "CNI_ARGS: $CNI_ARGS" >> $LOGFILE

        local cidr_filtering_cni_label="cidr-filtering-cni"
        local cni_spec_name=$(echo "$STDIN" | jq -r ".name")
        local pod_namespace=""

        for i in ${CNI_ARGS//;/ }
        do
            case $i in
            "K8S_POD_NAMESPACE="*)
                pod_namespace=$(echo $i | awk -F'=' '{print $2}')
                if [[ "$pod_namespace" == "" ]]; then
                    exitWithError "${CNI_VERSION}" "Failed to parse pod namespace from CNI_ARGS"
                fi
            ;;
            esac
        done

        mkdir -p /var/run/netns/
        ln -sfT "$CNI_NETNS" /var/run/netns/"${CNI_CONTAINERID}"

        # Check API access
        kubectl --kubeconfig=/etc/cni/net.d/cidr-filtering.d/cidr-filtering.kubeconfig api-resources > /dev/null || exitWithError "${CNI_VERSION}" "Failed to reach kubernetes API server"

        ip netns exec "$CNI_CONTAINERID" $(create_table ${NFT_BRIDGE_TABLE} ${NFT_TABLE}) || exitWithError "${CNI_VERSION}" "Failed to create table ${NFT_BRIDGE_TABLE} ${NFT_TABLE}"
        ip netns exec "$CNI_CONTAINERID" $(create_table ${NFT_BRIDGE_TABLE} ${NFT_TABLE}) || exitWithError "${CNI_VERSION}" "Failed to create table ${NFT_BRIDGE_TABLE} ${NFT_TABLE}"

        # create base chains
        ip netns exec "$CNI_CONTAINERID" $(create_base_chain ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_INGRESS_CHAIN} ${NFT_INGRESS_HOOK}) || exitWithError "${CNI_VERSION}" "Failed to create base chain ${NFT_INGRESS_CHAIN}"
        ip netns exec "$CNI_CONTAINERID" $(create_base_chain ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_POSTROUTING_CHAIN} ${NFT_EGRESS_HOOK}) || exitWithError "${CNI_VERSION}" "Failed to create bridge base chain ${NFT_POSTROUTING_CHAIN}"

        # filter chains
        ip netns exec "$CNI_CONTAINERID" $(create_chain ${NFT_BRIDGE_TABLE} ${NFT_TABLE} m-ingress) || exitWithError "${CNI_VERSION}" "Failed to add chain m-ingress"
        ip netns exec "$CNI_CONTAINERID" $(create_chain ${NFT_BRIDGE_TABLE} ${NFT_TABLE} m-egress) || exitWithError "${CNI_VERSION}" "Failed to add chain m-egress"

        # setup prerouting chain
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_INGRESS_CHAIN} ether type arp counter accept) || exitWithError "${CNI_VERSION}" "Failed to allow arp for ingress"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_INGRESS_CHAIN} iifname $CNI_IFNAME counter jump m-ingress) || exitWithError "${CNI_VERSION}" "Failed to add rule: jump m-ingress"

        # setup postrouting chain
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_POSTROUTING_CHAIN} ether type arp counter accept) || exitWithError "${CNI_VERSION}" "Failed to allow arp for egress"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_POSTROUTING_CHAIN} oifname $CNI_IFNAME counter jump m-egress) || exitWithError "${CNI_VERSION}" "Failed to add rule: jump m-egress"

        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${NFT_BRIDGE_TABLE}" "${NFT_TABLE}" m-egress counter meta mark set meta mark "&" 0xfffcffff) || exitWithError "${CNI_VERSION}" "Failed to add rule: set meta mark & 0xfffcffff"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${NFT_BRIDGE_TABLE}" "${NFT_TABLE}" m-ingress counter meta mark set meta mark "&" 0xfffcffff) || exitWithError "${CNI_VERSION}" "Failed to add rule: set meta mark & 0xfffcffff"

        _process_configmap() {
            local configmap_name="$1"
            local configmap_namespace="$2"
            local config_id="$(echo "${configmap_name}${configmap_namespace}" | sha1sum )"
            config_id="${config_id:0:5}" # use first 5 characters to identify configuration specified in a configmap

            # the json config in configmap is escaped when the configmap itself is obtained in json. To be able to work with it with jq, we need to remove '\n', '\'', spaces and leading/trailing character (which is an apostrophe)
            local config=$(kubectl --kubeconfig=/etc/cni/net.d/cidr-filtering.d/cidr-filtering.kubeconfig get cm ${configmap_name} -n ${configmap_namespace} -o json | jq -c '.data."config.json"' | sed 's#\\n##g;s#\\##g;s# ##g;s/^.//;s/.$//')

            create_rules_for_filtering "$config_id" "$config" "${NFT_BRIDGE_TABLE}" "ingress"
            create_rules_for_filtering "$config_id" "$config" "${NFT_BRIDGE_TABLE}" "egress"
        }
        
        for configmap_name in $(kubectl --kubeconfig=/etc/cni/net.d/cidr-filtering.d/cidr-filtering.kubeconfig get cm -l${cni_spec_name},${cidr_filtering_cni_label} -n ${pod_namespace} -o jsonpath='{range .items[*]}{@.metadata.name}{"\n"}' | head -n -1); do
            _process_configmap $configmap_name $pod_namespace
        done

        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${NFT_BRIDGE_TABLE}" "${NFT_TABLE}" m-ingress meta mark "&" 0x00030000 == 0x00030000 counter return) || exitWithError "${CNI_VERSION}" "Failed to add rule: mark & 0x00030000 == 0x00030000 counter return"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${NFT_BRIDGE_TABLE}" "${NFT_TABLE}" m-ingress counter drop) || exitWithError "${CNI_VERSION}" "Failed to add rule: drop"

        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${NFT_BRIDGE_TABLE}" "${NFT_TABLE}" m-egress meta mark "&" 0x00030000 == 0x00030000 counter return) || exitWithError "${CNI_VERSION}" "Failed to add rule: mark & 0x00030000 == 0x00030000 counter return"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${NFT_BRIDGE_TABLE}" "${NFT_TABLE}" m-egress counter drop) || exitWithError "${CNI_VERSION}" "Failed to add rule: drop"

        exitWithSuccess "${CNI_VERSION}" "${CNI_PREV_RESULT}"
    ;;

    DEL)
        echo "Delete $CNI_CONTAINERID" >> $LOGFILE
        rm -f /var/run/netns/"$CNI_CONTAINERID"
    ;;

    VERSION)
        echo "{\"cniVersion\":\"0.3.1\",\"supportedVersions\":[\"0.1.0\",\"0.2.0\",\"0.3.0\",\"0.3.1\"]}"
    ;;

    *)
        exitWithError "${CNI_VERSION}" "Unrecognized CNI command: ${CNI_COMMAND}"
    ;;

    esac
}

if [[ $TEST == false ]]; then
    main
fi
